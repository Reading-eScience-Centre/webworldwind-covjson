<!DOCTYPE html>
<!-- This is a very simple example of using Web World Wind. -->
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>World Wind CovJSON Example</title>
    <script src="https://cdn.jsdelivr.net/xndarray/0.3/xndarray.min.js"></script>
    <script src="http://worldwindserver.net/webworldwind/worldwindlib.js" type="text/javascript"></script>
    <script src="libs/palette.js" type="text/javascript"></script>
</head>
<body>
<div style="position: absolute; top: 50px; left: 50px;">
    <!-- Create a canvas for Web World Wind. -->
    <canvas id="canvasOne" width="1024" height="768">
        Your browser does not support HTML5 Canvas.
    </canvas>
</div>
<script>
var TiledCanvasLayer = function (sector, tileWidth, tileHeight, displayName) {
  WorldWind.TiledImageLayer.call(this, sector, new WorldWind.Location(90, 180), 19, "image/x-canvas", displayName, tileWidth, tileHeight);
}

TiledCanvasLayer.prototype = Object.create(WorldWind.TiledImageLayer.prototype);

/**
* overrides TiledImageLayer.prototype.retrieveTileImage
*/
TiledCanvasLayer.prototype.retrieveTileImage = function (dc, tile, suppressRedraw) {
  if (this.currentRetrievals.indexOf(tile.imagePath) < 0) {
      if (this.absentResourceList.isResourceAbsent(tile.imagePath)) {
          return;
      }

      var imagePath = tile.imagePath,
          cache = dc.gpuResourceCache,
          canvas = dc.currentGlContext.canvas,
          layer = this;

      var canvas = document.createElement('canvas');
      canvas.width = tile.tileWidth;
      canvas.height = tile.tileHeight;
      
      this.drawCanvasTile(canvas, tile);
      
      var texture = layer.createTexture(dc, tile, canvas);
      layer.removeFromCurrentRetrievals(imagePath);

      if (texture) {
          cache.putResource(imagePath, texture, texture.size);

          layer.currentTilesInvalid = true;
          layer.absentResourceList.unmarkResourceAbsent(imagePath);

          if (!suppressRedraw) {
              // Send an event to request a redraw.
              var e = document.createEvent('Event');
              e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);
              canvas.dispatchEvent(e);
          }
      }

      this.currentRetrievals.push(imagePath);
  }
}

var CovJSONGridLayer = function (covjson, parameter, displayName) {
  var data = covjson.ranges[parameter]
  var coords = {}
  for (var axisName in covjson.domain.axes) {
    var axis = covjson.domain.axes[axisName]
    if ('start' in axis) {
      var vals = new Float64Array(axis.num)
      var step = (axis.stop - axis.start) / (axis.num - 1)
      for (var i=0; i < axis.num; i++) {
        vals[i] = axis.start + i*step
      }
    } else {
      var vals = axis.values
    }
    coords[axisName] = vals
  }
  var arr = xndarray(data.values, {
    shape: data.shape,
    names: data.axisNames,
    coords: coords
  })
  arr = toAscendingCoords(arr)
  this.data = arr
  
  this.paletteExtent = minMax(data.values)
  this._palette = hexToRgb(palette('tol-dv', 256))
  
  TiledCanvasLayer.call(this, new WorldWind.Sector(-90,90,-180,180), 256, 256, displayName)
}

CovJSONGridLayer.prototype = Object.create(TiledCanvasLayer.prototype);

CovJSONGridLayer.prototype.drawCanvasTile = function (canvas, tile) {
  var ctx = canvas.getContext('2d')
  var tileWidth = tile.tileWidth
  var tileHeight = tile.tileHeight
  
  var imgData = ctx.getImageData(0, 0, tileWidth, tileHeight)
  var rgba = xndarray(imgData.data, {
    shape: [tileHeight, tileWidth, 4],
    names: ['y','x','c']
  })
  
  // data coordinates
  var lats = this.data.coords.get('y')
  var lons = this.data.coords.get('x')
  
  // extended data bounding box (first and last cell gets extended since we don't have explicit bounds)
  var latMin = lats.get(0) - (lats.get(1) - lats.get(0)) / 2
  var latMax = lats.get(lats.size-1) + (lats.get(lats.size-1) - lats.get(lats.size-2)) / 2
  var lonMin = lons.get(0) - (lons.get(1) - lons.get(0)) / 2
  var lonMax = lons.get(lons.size-1) + (lons.get(lons.size-1) - lons.get(lons.size-2)) / 2    
  
  // tile coordinates
  var sector = tile.sector
  var tileLatMin = sector.minLatitude
  var tileLonMin = sector.minLongitude
  var tileLatMax = sector.maxLatitude
  var tileLonMax = sector.maxLongitude
  var tileLatStep = (tileLatMax - tileLatMin) / tileHeight
  var tileLonStep = (tileLonMax - tileLonMin) / tileWidth
  
  // used for longitude wrapping
  var lonRange = [lonMin, lonMin + 360]
  
  for (var tileX = 0; tileX < tileWidth; tileX++) {
    for (var tileY = 0; tileY < tileHeight; tileY++) {
      var lat = (tileHeight - 1 - tileY) * tileLatStep + tileLatMin
      var lon = tileX * tileLonStep + tileLonMin
      
      // we first check whether the tile pixel is outside the bounding box
      // in that case we skip it as we do not want to extrapolate
      if (lat < latMin || lat > latMax) {
        continue
      }

      lon = wrapNum(lon, lonRange, true)
      if (lon < lonMin || lon > lonMax) {
        continue
      }
      
      // read the value of the corresponding grid cell
      var iLat = indexOfNearest(lats, lat)
      var iLon = indexOfNearest(lons, lon)
      var val = this.data.xget({y: iLat, x: iLon})
      
      // find the right color in the palette
      var colorIdx = scale(val, this._palette, this.paletteExtent)
      var color = this._palette[colorIdx]
      if (!color) {
        // out of scale
        continue
      }
      
      // and draw it
      rgba.xset({y: tileY, x: tileX, c: 0}, color[0])
      rgba.xset({y: tileY, x: tileX, c: 1}, color[1])
      rgba.xset({y: tileY, x: tileX, c: 2}, color[2])
      rgba.xset({y: tileY, x: tileX, c: 3}, 255)
    }
  }
  
  ctx.putImageData(imgData, 0, 0)
}

// from https://github.com/Leaflet/Leaflet/blob/master/src/core/Util.js
function wrapNum (x, range, includeMax) {
  var max = range[1]
  var min = range[0]
  var d = max - min
  return x === max && includeMax ? x : ((x - min) % d + d) % d + min
}

function minMax (vals) {
  var min = Infinity
  var max = -Infinity
  for (var i=0; i < vals.length; i++) {
    var val = vals[i]
    if (val === null) continue
    if (val < min) min = val
    if (val > max) max = val
  }
  return min === Infinity ? [undefined, undefined] : [min, max]
}

function toAscendingCoords (xndarr) {
  var res = xndarr
  xndarr.coords.forEach(function(v,k) {
    if (v.size > 1 && typeof v.get(0) === 'number' && v.get(0) > v.get(1)) {
      res = res.xstep({[k]: -1})
    }
  })
  return res
}

/** Return the index of the value closest to 'x' in 'a' using binary search.
 *  'a' must be ascending.
 */
function indexOfNearest (a, x) {
  if (a.dimension !== 1) {
    throw new Error('ndarray must be 1D')
  }
  var lo = -1
  var hi = a.size
  while (hi - lo > 1) {
    var mid = Math.round((lo + hi) / 2)    
    if (a.get(mid) <= x) {
      lo = mid
    } else {
      hi = mid
    }
  }
  if (a.get(lo) === x) hi = lo
  if (lo === -1) lo = hi
  if (hi === a.size) hi = lo
  if (Math.abs(x - a.get(lo)) <= Math.abs(x - a.get(hi))) {
    return lo
  } else {
    return hi
  }
}

function hexToRgb (colors) {
  return colors.map(function(color) {
    var c = parseInt(color, 16)
    return [c >> 16, (c >> 8) & 255, c & 255]
  })
}

function scale (val, palette, extent) {
  // scale val to [0,paletteSize-1] using the palette extent
  // (IDL bytscl formula: http://www.exelisvis.com/docs/BYTSCL.html)
  var scaled = Math.trunc((palette.length - 1 + 0.9999) * (val - extent[0]) / (extent[1] - extent[0]))
  return scaled
}

var CovJSONVectorLayer = function (covjson, parameter, displayName) {
  // TODO convert CovJSON to GeoJSON and use GeoJSONParser, return RenderableLayer
}

var CovJSONVectorDomainTypes = [
  'VerticalProfile','PointSeries','Point','MultiPointSeries','MultiPoint',
  'PolygonSeries','Polygon','MultiPolygonSeries','MultiPolygon','Trajectory',
  'Section'
]

var CovJSONLayer = function (covjson, parameter, displayName) {
  var domainType = covjson.domainType || covjson.domain.domainType
  if (domainType === 'Grid') {
    return new CovJSONGridLayer(covjson, parameter, displayName)
  } else if (CovJSONVectorDomainTypes.indexOf(domainType) !== -1) {
    return CovJSONVectorLayer(covjson, parameter, displayName)
  } else {
    throw new Error('Unsupported CovJSON domain type: ' + domainType)
  }
}


// Register an event listener to be called when the page is loaded.
window.addEventListener("load", eventWindowLoaded, false);

// Define the event listener to initialize Web World Wind.
function eventWindowLoaded() {
    // Create a World Window for the canvas.
    var wwd = new WorldWind.WorldWindow("canvasOne");

    // Add some image layers to the World Window's globe.
    wwd.addLayer(new WorldWind.BMNGOneImageLayer());
    wwd.addLayer(new WorldWind.BingAerialWithLabelsLayer());

    // Add a compass, a coordinates display and some view controls to the World Window.
    wwd.addLayer(new WorldWind.CompassLayer());
    wwd.addLayer(new WorldWind.CoordinatesDisplayLayer(wwd));
    wwd.addLayer(new WorldWind.ViewControlsLayer(wwd));
    
    // Add a CovJSON layer
    fetch('grid.covjson').then(function (resp) {
      return resp.json();
    }).then(function (covjson) {
      // render first parameter
      var param = Object.keys(covjson.parameters)[0]
      var covjsonLayer = CovJSONLayer(covjson, param, 'CovJSON');
      wwd.addLayer(covjsonLayer);
    });   
}
</script>
</body>
</html>